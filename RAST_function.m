function  [T]=RAST_function(matfile,mainfolder,foldername,error,pixsize,degrot,nsmooth,numlines,nei_deg,scorefigs,crystal)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ù
%
% % Main "skeleton" script of the RAST algorithm, is called by "RAST_Running.m".
%
% The main steps of this script include:
%
% (4) Automated Picture smoothing to cancel part of SEM imaging noise
%
% (5) Calling "picture_segmentation.m" which segments the pictures, finds
% lines and returns a matrix of lines (could be improved by using several
% cells/datastack rather than a unique matrix)
%
% (6) Scoring procedure, finds amount of lines similar in orientation in neighbour
% segments of each line and targets specially oriented "noise lines" to distinguish noise from real slip traces
%
% (7) Calling "line_processing.m" which does most of the hard work: matches lines detected to the
% theoretical slip trace directions, and associate possible slip planes to every line
% detected. Also generate the figures. Then returns various match data for data
% analysis.
%
% (8) Writes the results in a table and exports in an excel spread sheet, per picture and per grain
% orientation.
%
% 
% The output "T", the table containing all data, also contains the "error"
% and "pixsize" used for easy plotting using the main table generated by
% combining all individual runs (see parent "RAST_Running.m" code file).
%
%
%%%%%%%%%%%%%%%%%%%%%%%ù


%close all
%clear all
filename=foldername;

% prompt = {'Chose a name for your file. It will create a folder where pictures and results are stored'};
% dlgtitle = 'Saving the table';
% dims = [1 100];
% filename = inputdlg(prompt,dlgtitle,dims);

path=strcat(pwd,'\',mainfolder,'\',filename{1});
mkdir(path)

no=0;
Eulers={};
Pictures={};
BWss={};
xi2={};
yi2={};

load(matfile) %loads your .mat

%%%%%%%%%%%%%
% (4) Smoothing pictures loop

for i=1:1:no

    %g = waitbar(0,sprintf('Smoothing pictures (picture %.0f of %.0f)',[i
    %no])); waitbar slow the code down unfortunately

    fprintf('Smoothing pictures (picture %.0f of %.0f)',[i no]);
    fprintf('\n');

    count=0;

    I=Pictures{i};
    BWs=BWss{i};


    %%%%Note the following lines were designed to automatically get rid of
    %%%%the SEM legend, but it only works if consists of black pixels. Obsolete since cropping, adapt if needed depending on your SEM pictures.
    %%% ignores legend out of pictures during smoothing (obsolete if you've
    %%% cropped out the legend!)

    [Ix,Iy]=size(I);
    l=5; %there is also a white line before the picture in SEM pictures we made, so needs to pass at least 1 non black pixel.
    j=Ix;
    while l~=0
        if I(j,Iy)~=0
            l=l-1;
        end
        j=j-1;
    end

    L=I(1:j,:); %only L will be smoothed, keeping the legend at the bottom of the picture intact

    %%%%%%%
    %%% Now smoothing

    for k=1:nsmooth %repeats nsmooth times
        count=count+1;
        %waitbar(count/(nsmooth))

        L = wiener2(L,[5 5]); % smoothing of the picture to get rid of SEM noise (which reacts poorly with edge detection) can be adjusted if the picture quality varies
    end

    I(1:j,:)=L;
    I(BWs)=0;

    Pictures{i}=I;
    %close(g)
    pause(0.1)

end

%close(g)

pause(0.1)

close all


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%(5) Processing every picture for segmentation and line detection. coefmat
%contains all line detected information i.e position and orientation

for i=1:1:no

    ii=i;

    [coefmat,cuth,cutl]=RAST_picture_segmentation(Pictures{i},ii,no,path,pixsize,numlines,degrot);

    coefmat_all{i}=coefmat;
    cuths{i}=cuth;
    cutls{i}=cutl;

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (6) Line scoring loop. Sorry for the intense looping, old young beginner me writing
% it.


for m=1:1:no

    coefmat=coefmat_all{m}; %get the picture's matrix of lines
    cuth=cuths{m};
    cutl=cutls{m};

    %g = waitbar(0,sprintf('Determining the score of every line detected (picture %.0f of %.0f)',[m no]));
    fprintf('Determining the score of every line detected (picture %.0f of %.0f)',[m no]);
    fprintf('\n');
    
    count=0;

    for i=1:1:(cuth) %check all lines
        for j=1:1:(cutl)

            %X=i; fyi
            %Y=j;

            count=count+1;
            %waitbar(count/(cuth*cutl))

            for o=1:1:10 %checks neighbours at 10 orders max, increase if you want, but computation time may severely increase.
                for k=-o:1:o %checks all neigbours
                    for l=-o:1:o
                        if i+k<1 || j+l<1 || i+k>(cuth) || j+l>(cutl) || i-k<1 || j-l<1 || i-k>(cuth) || j-l>(cutl) %avoid going out of the pictures' boundaries
                            skip=0;%fyi
                        elseif k==o || l==o || k==-o || l==-o %only check if at current order (could be improved if k and l were defined differently)

                            cos_1=coefmat(i,j,1:numlines); %line number of current line
                            cos_2=coefmat(i+k,j+l,1:numlines); %line number of neibs

                            lno=0;

                            for co_1b=cos_1

                                lno=lno+1;

                                lno2=0;

                                for co_2b=cos_2

                                    lno2=lno2+1;

                                    A_1=coefmat(i,j,numlines+1+6*(lno-1));
                                    A_2=coefmat(i+k,j+l,numlines+1+6*(lno2-1));

                                    co_1=co_1b-degrot; %(ignore degrot for scoring, easier brain gymnastics...)
                                    co_2=co_2b-degrot;

                                    if A_1==0 %skip if the current line is on mask (could be put earlier for faster computation?)
                                        skip=0;%fyi

                                    elseif A_2==0 %skip neighbour if it is on the mask
                                        skip=0;%fyi

                                    elseif (abs(co_1-co_2)<nei_deg) %if orientations are similar, based on the value delta chosen (nei_deg)

                                         coefmat(i,j,numlines+5+6*(lno-1))=coefmat(i,j,numlines+5+6*(lno-1))+1/(o^2); %score increases +1/order² per similar neibour

                                    elseif ((45-nei_deg)<abs(co_1) && abs(co_1)<(45+nei_deg)) && ((90-nei_deg)<abs(co_1-co_2) && abs(co_1-co_2)<(90+nei_deg)) %NB : not sure that nei_deg, the fluctuation around a specific trace orientation, applies to a noise area, maybe nei_deg should be different for the noise
                                         coefmat(i,j,numlines+5+6*(lno-1))=coefmat(i,j,numlines+5+6*(lno-1))-10/(o); %if line is 45° and has a neighbour at 90° (-45°) ==> likely to be noise so reduces score.

                                    elseif (((0-nei_deg)<co_1 && co_1<(0+nei_deg))||(((90-nei_deg)<co_1)||(co_1<(-90+nei_deg)))) && ((((45-nei_deg)<abs(co_2) && abs(co_2)<(45+nei_deg)))||(((-45-nei_deg)<abs(co_2) && abs(co_2)<(-45+nei_deg)))) %if line is horizontal and has a 45° neigbour
                                         coefmat(i,j,numlines+5+6*(lno-1))=coefmat(i,j,numlines+5+6*(lno-1))-10/(o); %if line is +-90° or 0°, and has a 45° neighbour ==> likely to be noise so reduces score.

                                    end

                                end

                            end
                        end

                    end
                end
            end

        end
    end

    coefmat_all{m}=coefmat;%updates mat with new mat with replaced score values
    %close(g)
    pause(0.1)

end

%%%%%%%%%%%%%%%%%%%%%
%(7) Line processing loop (matching, counting, figure making etc.)

for i=1:1:no

    ii=i;

    coefmat=coefmat_all{i};
    cuth=cuths{i};
    cutl=cutls{i};

    [sol]=RAST_line_processing(Eulers{i},Pictures{i},ii,no,path,coefmat,degrot,error,cuth,cutl,nei_deg,pixsize,numlines,scorefigs,crystal);

    solz{i}=sol; %contains total match counts and various other data.

end

%%%%%%%%%%%%%%%%%%%%%%%%

% (8) Sorting the data to export to excel spread sheet

% The final output from line.processing.m looks like this:
% 
% sol=[m100 m110 m112 m123 u100 u110 u112 u123 u111...
%     m100110 m100112 m100123 m110112 m110123 m112123...
%     m110112123 m100112123 m100110123 m100110112 nomatch...
%     tm100 tm110 tm112 tm123 tu100 tu110 tu112 tu123 tu111...
%     tm100110 tm100112 tm100123 tm110112 tm110123 tm112123...
%     tm110112123 tm100112123 tm100110123 tm100110112 tnomatch...
%     pm100 pm110 pm112 pm123 pu100 pu110 pu112 pu123 pu111...
%     pm100110 pm100112 pm100123 pm110112 pm110123 pm112123...
%     pm110112123 pm100112123 pm100110123 pm100110112 pnomatch...
%     ptm100 ptm110 ptm112 ptm123 ptu100 ptu110 ptu112 ptu123 ptu111...
%     ptm100110 ptm100112 ptm100123 ptm110112 ptm110123 ptm112123...
%     ptm110112123 ptm100112123 ptm100110123 ptm100110112 ptnomatch...
%     nlines tnlines]

%initializing end values

neii=20; %8 = 1 order, 12 at n order
neii=neii+1; %not sure what exactly I did here, some matrix row/column boundary condition I assume

Euler=zeros(length(Eulers)*neii,3);
grainID=zeros(length(Eulers)*neii,1);
pictureID=zeros(length(Eulers)*neii,1);
ST=zeros(length(Eulers)*neii,1);

nlines=zeros(length(Eulers)*neii,1);
tnlines=zeros(length(Eulers)*neii,1);

IR=zeros(length(Eulers)*neii,1); % identification range "error" used
N=zeros(length(Eulers)*neii,1); % segmentation size

m100=zeros(length(Eulers)*neii,1);
m110=zeros(length(Eulers)*neii,1);
m112=zeros(length(Eulers)*neii,1);
m123=zeros(length(Eulers)*neii,1);
u100=zeros(length(Eulers)*neii,1);
u110=zeros(length(Eulers)*neii,1);
u112=zeros(length(Eulers)*neii,1);
u123=zeros(length(Eulers)*neii,1);
u111=zeros(length(Eulers)*neii,1);
m100110=zeros(length(Eulers)*neii,1);
m100112=zeros(length(Eulers)*neii,1);
m100123=zeros(length(Eulers)*neii,1);
m110112=zeros(length(Eulers)*neii,1);
m110123=zeros(length(Eulers)*neii,1);
m112123=zeros(length(Eulers)*neii,1);
m110112123=zeros(length(Eulers)*neii,1);
m100112123=zeros(length(Eulers)*neii,1);
m100110123=zeros(length(Eulers)*neii,1);
m100110112=zeros(length(Eulers)*neii,1);
nomatch=zeros(length(Eulers)*neii,1);

tm100=zeros(length(Eulers)*neii,1);
tm110=zeros(length(Eulers)*neii,1);
tm112=zeros(length(Eulers)*neii,1);
tm123=zeros(length(Eulers)*neii,1);
tu100=zeros(length(Eulers)*neii,1);
tu110=zeros(length(Eulers)*neii,1);
tu112=zeros(length(Eulers)*neii,1);
tu123=zeros(length(Eulers)*neii,1);
tu111=zeros(length(Eulers)*neii,1);
tm100110=zeros(length(Eulers)*neii,1);
tm100112=zeros(length(Eulers)*neii,1);
tm100123=zeros(length(Eulers)*neii,1);
tm110112=zeros(length(Eulers)*neii,1);
tm110123=zeros(length(Eulers)*neii,1);
tm112123=zeros(length(Eulers)*neii,1);
tm110112123=zeros(length(Eulers)*neii,1);
tm100112123=zeros(length(Eulers)*neii,1);
tm100110123=zeros(length(Eulers)*neii,1);
tm100110112=zeros(length(Eulers)*neii,1);
tnomatch=zeros(length(Eulers)*neii,1);

pm100=zeros(length(Eulers)*neii,1);
pm110=zeros(length(Eulers)*neii,1);
pm112=zeros(length(Eulers)*neii,1);
pm123=zeros(length(Eulers)*neii,1);
pu100=zeros(length(Eulers)*neii,1);
pu110=zeros(length(Eulers)*neii,1);
pu112=zeros(length(Eulers)*neii,1);
pu123=zeros(length(Eulers)*neii,1);
pu111=zeros(length(Eulers)*neii,1);
pm100110=zeros(length(Eulers)*neii,1);
pm100112=zeros(length(Eulers)*neii,1);
pm100123=zeros(length(Eulers)*neii,1);
pm110112=zeros(length(Eulers)*neii,1);
pm110123=zeros(length(Eulers)*neii,1);
pm112123=zeros(length(Eulers)*neii,1);
pm110112123=zeros(length(Eulers)*neii,1);
pm100112123=zeros(length(Eulers)*neii,1);
pm100110123=zeros(length(Eulers)*neii,1);
pm100110112=zeros(length(Eulers)*neii,1);
pnomatch=zeros(length(Eulers)*neii,1);

ptm100=zeros(length(Eulers)*neii,1);
ptm110=zeros(length(Eulers)*neii,1);
ptm112=zeros(length(Eulers)*neii,1);
ptm123=zeros(length(Eulers)*neii,1);
ptu100=zeros(length(Eulers)*neii,1);
ptu110=zeros(length(Eulers)*neii,1);
ptu112=zeros(length(Eulers)*neii,1);
ptu123=zeros(length(Eulers)*neii,1);
ptu111=zeros(length(Eulers)*neii,1);
ptm100110=zeros(length(Eulers)*neii,1);
ptm100112=zeros(length(Eulers)*neii,1);
ptm100123=zeros(length(Eulers)*neii,1);
ptm110112=zeros(length(Eulers)*neii,1);
ptm110123=zeros(length(Eulers)*neii,1);
ptm112123=zeros(length(Eulers)*neii,1);
ptm110112123=zeros(length(Eulers)*neii,1);
ptm100112123=zeros(length(Eulers)*neii,1);
ptm100110123=zeros(length(Eulers)*neii,1);
ptm100110112=zeros(length(Eulers)*neii,1);
ptnomatch=zeros(length(Eulers)*neii,1);

count=1;

for j=1:1:length(Eulers)

    e=Eulers{j};
    eul=e{1};

    sols=solz{j};

    for l=1:1:neii

        y=sols{l};
        i=l+neii*(j-1);

        Euler(i,:)=str2num(eul);
        if j~=1
            if Euler(i,:)==Euler(i-1,:) %wrote so that pictures from the same grain must be next to each other! Checks if previous Euler entered has the same angles i.e. is the same as current grain
            else
               count=count+1;

            end 
        end

        grainID(i,:)=count; 

        pictureID(i,:)=j;

        ST(i,1)=l-1;

        %Storing every value of interest:

        nlines(i,1)=y(end-1); %total amount of lines detected for this nei
        tnlines(i,1)=y(end); %total amount of test lines generated (720 are generate each time a new grain+score+picture combination is processed in line_processing) A lot of this data is redundant (same stats as long as same grain). 

        m100(i,1)=y(1); % match at least one plane
        m110(i,1)=y(2);
        m112(i,1)=y(3);
        m123(i,1)=y(4);
        u100(i,1)=y(5); %match exclusively said plane
        u110(i,1)=y(6);
        u112(i,1)=y(7);
        u123(i,1)=y(8);
        u111(i,1)=y(9); % match exclusively 112 AND/OR 123 and therefore is definitely <111> direction
        m100110(i,1)=y(10); % match exclusively plane A AND B (here 100 and 110) = it does not match 112 nor 123!
        m100112(i,1)=y(11);
        m100123(i,1)=y(12);
        m110112(i,1)=y(13);
        m110123(i,1)=y(14);
        m112123(i,1)=y(15);
        m110112123(i,1)=y(16); % match exclusively plane A AND B AND C (here 110 and 112 and 123) = it does not match 100!
        m100112123(i,1)=y(17);
        m100110123(i,1)=y(18);
        m100110112(i,1)=y(19);
        nomatch(i,1)=y(20); % match nothing (very unlikely if IR >5 degree)

        %same for test lines uniformly distributed between 0 - 180, test = "t"
        tm100(i,1)=y(21);
        tm110(i,1)=y(22);
        tm112(i,1)=y(23);
        tm123(i,1)=y(24);
        tu100(i,1)=y(25);
        tu110(i,1)=y(26);
        tu112(i,1)=y(27);
        tu123(i,1)=y(28);
        tu111(i,1)=y(29);
        tm100110(i,1)=y(30);
        tm100112(i,1)=y(31);
        tm100123(i,1)=y(32);
        tm110112(i,1)=y(33);
        tm110123(i,1)=y(34);
        tm112123(i,1)=y(35);
        tm110112123(i,1)=y(36);
        tm100112123(i,1)=y(37);
        tm100110123(i,1)=y(38);
        tm100110112(i,1)=y(39);
        tnomatch(i,1)=y(40);

        %Now showing the values as percentages of the total amount of lines
        %detected in the picture at this score, percentage = "p":

        pm100(i,1)=y(41);
        pm110(i,1)=y(42);
        pm112(i,1)=y(43);
        pm123(i,1)=y(44);
        pu100(i,1)=y(45);
        pu110(i,1)=y(46);
        pu112(i,1)=y(47);
        pu123(i,1)=y(48);
        pu111(i,1)=y(49);
        pm100110(i,1)=y(50);
        pm100112(i,1)=y(51);
        pm100123(i,1)=y(52);
        pm110112(i,1)=y(53);
        pm110123(i,1)=y(54);
        pm112123(i,1)=y(55);
        pm110112123(i,1)=y(56);
        pm100112123(i,1)=y(57);
        pm100110123(i,1)=y(58);
        pm100110112(i,1)=y(59);
        pnomatch(i,1)=y(60);

        % percentage for the test lines "p", "t":

        ptm100(i,1)=y(61);
        ptm110(i,1)=y(62);
        ptm112(i,1)=y(63);
        ptm123(i,1)=y(64);
        ptu100(i,1)=y(65);
        ptu110(i,1)=y(66);
        ptu112(i,1)=y(67);
        ptu123(i,1)=y(68);
        ptu111(i,1)=y(69);
        ptm100110(i,1)=y(70);
        ptm100112(i,1)=y(71);
        ptm100123(i,1)=y(72);
        ptm110112(i,1)=y(73);
        ptm110123(i,1)=y(74);
        ptm112123(i,1)=y(75);
        ptm110112123(i,1)=y(76);
        ptm100112123(i,1)=y(77);
        ptm100110123(i,1)=y(78);
        ptm100110112(i,1)=y(79);
        ptnomatch(i,1)=y(80);

        IR(i,1)=error;
        N(i,1)=pixsize;

    end

end

%Filling table and saving results to a file.

close all

T = table(Euler,grainID,pictureID,ST,IR,N,...
    m100,m110,m112,m123,u100,u110,u112,u123,u111,...
    m100110,m100112,m100123,m110112,m110123,m112123,...
    m110112123,m100112123,m100110123,m100110112,nomatch,...
    tm100,tm110,tm112,tm123,tu100,tu110,tu112,tu123,tu111,...
    tm100110,tm100112,tm100123,tm110112,tm110123,tm112123,...
    tm110112123,tm100112123,tm100110123,tm100110112,tnomatch,...
    pm100,pm110,pm112,pm123,pu100,pu110,pu112,pu123,pu111,...
    pm100110,pm100112,pm100123,pm110112,pm110123,pm112123,...
    pm110112123,pm100112123,pm100110123,pm100110112,pnomatch,...
    ptm100,ptm110,ptm112,ptm123,ptu100,ptu110,ptu112,ptu123,ptu111,...
    ptm100110,ptm100112,ptm100123,ptm110112,ptm110123,ptm112123,...
    ptm110112123,ptm100112123,ptm100110123,ptm100110112,ptnomatch,...
    nlines,tnlines);

fig = uifigure;
uit = uitable(fig,'Data',T); %shows table in matlab, can be copy pasted to your favoured software

imname=sprintf('%s_Table.xlsx', filename{1});
locname=fullfile(path, imname);
writetable(T,locname,'Sheet',1,'Range','A1') % saves as spreadsheet (I have used Excel)

imname=sprintf('%s_mat.mat', filename{1});
locname=fullfile(path, imname);
save(locname) %stores data for statistical testing, comment if you don't care (takes space)

